<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Balloon Trouble</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
            overflow: hidden;
            margin: 0;
            padding: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        
        .game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 60%, #4A6741 60%);
            overflow: hidden;
            cursor: crosshair;  /* Default cursor until custom crosshair is active */
        }
        
        .game-container.hide-cursor {
            cursor: none;  /* Hide default cursor when custom crosshair is active */
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            image-rendering: auto;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
        }
        
        .ui {
            position: absolute;
            top: 105px;
            left: 20px;
            color: white;
            font-size: clamp(14px, 2.5vw, 18px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 100;
            pointer-events: none;
        }
        
        .ui-right {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: clamp(14px, 2.5vw, 18px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 100;
            text-align: right;
            pointer-events: none;
        }
        
        .game-buttons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column-reverse;
            gap: clamp(5px, 1vw, 10px);
            align-items: flex-start;
        }
        
        .game-buttons button {
            padding: clamp(8px, 1.5vw, 10px) clamp(12px, 2vw, 15px);
            font-size: clamp(12px, 2vw, 14px);
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: clamp(80px, 15vw, 100px);
        }
        
        .game-buttons button:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }
        
        .language-switcher {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 300;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .language-row {
            display: flex;
            gap: 5px;
        }
        
        .language-btn {
            padding: 8px 12px;
            font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            min-width: 45px;
            text-align: center;
        }
        
        .language-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .language-btn.active {
            background: rgba(76, 175, 80, 0.8);
            border-color: #4CAF50;
        }
        
        .difficulty-menu {
            position: absolute;
            bottom: 150px;
            left: 140px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
            display: none;
        }
        
        .difficulty-menu button {
            display: block;
            width: 150px;
            margin: 5px 0;
            padding: 10px;
            font-size: 14px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .difficulty-menu button:hover {
            background: #45a049;
        }
        
        .difficulty-menu button.selected {
            background: #2196F3;
        }
        
        .difficulty-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            width: 500px;
            max-width: 90vw;
        }
        
        .difficulty-popup h2 {
            font-size: clamp(1.5em, 4vw, 2em);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .difficulty-popup p {
            margin-bottom: 30px;
            font-size: clamp(0.9em, 2.5vw, 1.1em);
            opacity: 0.9;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .difficulty-btn {
            padding: clamp(12px, 2vw, 15px) clamp(20px, 3vw, 25px);
            font-size: clamp(14px, 2.5vw, 16px);
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }
        
        .difficulty-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        @media (max-width: 600px) {
            .difficulty-popup {
                padding: 30px 20px;
                width: 95vw;
            }
            
            .difficulty-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .difficulty-btn {
                width: 80%;
                max-width: 200px;
            }
            
            .game-buttons {
                bottom: 10px;
                left: 10px;
            }
            
            .ui {
                top: 85px;
                left: 10px;
            }
            
            .ui-right {
                top: 10px;
                right: 10px;
            }
        }
        
        @media (max-height: 500px) {
            .difficulty-popup {
                padding: 20px 30px;
            }
            
            .difficulty-popup h2 {
                margin-bottom: 5px;
            }
            
            .difficulty-popup p {
                margin-bottom: 15px;
            }
        }
        
        .shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            max-width: 90vw;
            width: 400px;
        }
        
        .shop h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        .shop-coins {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #FFD700;
        }
        
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .shop button {
            padding: 12px 8px;
            font-size: 14px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.3;
        }
        
        .shop button:hover {
            background: #45a049;
        }
        
        .shop button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .shop-continue {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            background: #2196F3;
            margin-top: 5px;
        }
        
        .shop-continue:hover {
            background: #1976D2;
        }
        
        @media (max-width: 480px) {
            .shop {
                width: 95vw;
                padding: 15px;
            }
            
            .shop h2 {
                font-size: 20px;
            }
            
            .shop button {
                font-size: 12px;
                padding: 10px 5px;
                min-height: 55px;
            }
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        .restart-btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 150;
            display: none;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 0, 0, 0.8);
        }
        
        .crosshair::before {
            width: 2px;
            height: 30px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair::after {
            height: 2px;
            width: 30px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .credit-label {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 50;
            pointer-events: none;
            user-select: none;
            opacity: 0.8;
        }
    </style>
    <!-- Translation files -->
    <script src="translations/en.js"></script>
    <script src="translations/de.js"></script>
    <script src="translations/ro.js"></script>
    <script src="translations/fr.js"></script>
    <script src="translations/es.js"></script>
    <script src="translations/it.js"></script>
    <script src="index.js"></script> 
</head>
<body>
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="crosshair" id="crosshair"></div>
        
        <div class="language-switcher">
            <div class="language-row">
                <button class="language-btn" onclick="switchLanguage('en')" id="lang-en">EN</button>
                <button class="language-btn" onclick="switchLanguage('de')" id="lang-de">DE</button>
                <button class="language-btn" onclick="switchLanguage('ro')" id="lang-ro">RO</button>
            </div>
            <div class="language-row">
                <button class="language-btn" onclick="switchLanguage('fr')" id="lang-fr">FR</button>
                <button class="language-btn" onclick="switchLanguage('es')" id="lang-es">ES</button>
                <button class="language-btn" onclick="switchLanguage('it')" id="lang-it">IT</button>
            </div>
        </div>
        
        <div class="difficulty-popup" id="difficultyPopup">
            <h2>Balloon Trouble!</h2>
            <p>Select your preferred difficulty level to start the game.</p>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" id="easyStart">Easy</button>
                <button class="difficulty-btn" id="normalStart">Normal</button>
                <button class="difficulty-btn" id="hardStart">Hard</button>
            </div>
            <div>If you enjoy this game, please consider a donation - it helps a lot! ❤️</div>
			<div id="donate-button-container">
				<div id="donate-button"></div>
				<script src="https://www.paypalobjects.com/donate/sdk/donate-sdk.js" charset="UTF-8"></script>
				<script>
				PayPal.Donation.Button({
				env:'production',
				hosted_button_id:'Y2YR4AC4GZ8MW',
				image: {
				src:'https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif',
				alt:'Donate with PayPal button',
				title:'PayPal - The safer, easier way to pay online!',
				}
				}).render('#donate-button');
				</script>
			</div>
        </div>
        
        <div class="ui">
            <div id="coins-label">Coins: <span id="coins">0</span></div>
            <div id="house-hp-label">House HP: <span id="houseHP">25</span></div>
            <div id="wave-label">Wave: <span id="wave">1</span></div>
            <div id="enemies-left-label">Enemies Left: <span id="enemiesLeft">5</span></div>
        </div>
        
        <div class="ui-right">
            <div id="gun-level-label">Gun Level: <span id="gunLevel">1</span></div>
            <div id="turret-strength-label">Turret Strength: <span id="turretStrength">1</span></div>
            <div id="balloon-strength-label">Balloon Strength: <span id="balloonStrength">1</span></div>
        </div>
        
        <div class="game-buttons" id="gameButtons">
            <button id="pauseBtn">Pause</button>
            <button id="difficultyBtn">Difficulty</button>
            <!-- <button id="donateBtn">Donate ❤️</button> -->
        </div>
        
        <div class="difficulty-menu" id="difficultyMenu">
            <h3>Choose Difficulty</h3>
            <button id="easyBtn">Easy</button>
            <button id="normalBtn" class="selected">Normal</button>
            <button id="hardBtn">Hard</button>
            <button id="closeDifficultyBtn">Close</button>
        </div>
        
        <div class="shop" id="shop">
            <h2 id="shop-title">Upgrade Shop</h2>
            <p class="shop-coins" id="shop-coins-label">Coins: <span id="shopCoins">0</span></p>
            <div class="shop-grid">
                <button id="upgradeGun">
                    <span id="upgrade-gun-text">Upgrade Gun</span>
                    <span id="gun-cost-label">Cost: <span id="gunCost">50</span></span>
                </button>
                <button id="reinforceHouse">
                    <span id="reinforce-house-text">Reinforce House</span>
                    <span id="house-cost-label">Cost: <span id="houseCost">30</span></span>
                </button>
                <button id="buyTurret">
                    <span id="turret-button-text">Buy Turret</span>
                    <span id="turret-cost-label">Cost: <span id="turretCost">100</span></span>
                </button>
                <button id="repairHouse">
                    <span id="repair-house-text">Repair House</span>
                    <span id="repair-cost-label">Cost: <span id="repairCost">20</span></span>
                </button>
            </div>
            <button id="closeShop" class="shop-continue">Next Level</button>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p id="final-coins-label">Final Coins: <span id="finalCoins">0</span></p>
            <p id="waves-survived-label">Waves Survived: <span id="finalWave">0</span></p>
            <button class="restart-btn" id="restartBtn">Play Again</button>
        </div>
        
        <div class="credit-label" id="creditLabel">Created by Vlad Alexa - ThatGuyFrom89</div>
    </div>
    <script>
        // Translation system - always start with English unless there is a setting persisted in the local storage.
        let currentLanguage = localStorage.getItem('gameLanguage') || 'en';
        let t = window.translations[currentLanguage];
        setLanguage(currentLanguage);
        
        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('gameLanguage', lang);
            t = window.translations[lang];
            updateUITranslations();
        }
        
        function translate(key, params = {}) {
            let text = t[key] || key;
            // Replace template variables like {{wave}}
            Object.keys(params).forEach(param => {
                text = text.replace(`{{${param}}}`, params[param]);
            });
            return text;
        }
        
        function switchLanguage(lang) {
            setLanguage(lang);
            updateLanguageButtons();
            if (game) {
                // Force update of any dynamic content if game is running
                game.updateDynamicTranslations();
            }
        }
        
        function updateLanguageButtons() {
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('lang-' + currentLanguage).classList.add('active');
        }
        
        function updateUITranslations() {
            // Update static HTML elements
            document.querySelector('#difficultyPopup h2').textContent = t.gameTitle;
            document.querySelector('#difficultyPopup p').textContent = t.selectDifficulty;
            document.querySelector('#difficultyPopup > div:nth-child(4)').innerHTML = t.donationMessage;
            
            document.getElementById('easyStart').textContent = t.easy;
            document.getElementById('normalStart').textContent = t.normal;
            document.getElementById('hardStart').textContent = t.hard;
            
            document.getElementById('pauseBtn').textContent = t.pause;
            document.getElementById('difficultyBtn').textContent = t.difficulty;
            
            document.querySelector('#difficultyMenu h3').textContent = t.chooseDifficulty;
            document.getElementById('easyBtn').textContent = t.easy;
            document.getElementById('normalBtn').textContent = t.normal;
            document.getElementById('hardBtn').textContent = t.hard;
            document.getElementById('closeDifficultyBtn').textContent = t.close;
            
            document.getElementById('shop-title').textContent = t.upgradeShop;
            document.getElementById('shop-coins-label').innerHTML = t.coins + ': <span id="shopCoins">' + (document.getElementById('shopCoins')?.textContent || '0') + '</span>';
            document.getElementById('upgrade-gun-text').textContent = t.upgradeGun;
            document.getElementById('reinforce-house-text').textContent = t.reinforceHouse;
            document.getElementById('repair-house-text').textContent = t.repairHouse;
            document.getElementById('turret-button-text').textContent = t.buyTurret; // Default to "Buy Turret"
            document.getElementById('closeShop').textContent = t.nextLevel;
            
            document.querySelector('#gameOver h2').textContent = t.gameOver;
            document.getElementById('restartBtn').textContent = t.playAgain;
            
            // Update UI labels using their IDs
            document.getElementById('coins-label').innerHTML = t.coins + ': <span id="coins">' + (document.getElementById('coins')?.textContent || '0') + '</span>';
            document.getElementById('house-hp-label').innerHTML = t.houseHP + ': <span id="houseHP">' + (document.getElementById('houseHP')?.textContent || '100') + '</span>';
            document.getElementById('wave-label').innerHTML = t.wave + ': <span id="wave">' + (document.getElementById('wave')?.textContent || '1') + '</span>';
            document.getElementById('enemies-left-label').innerHTML = t.enemiesLeft + ': <span id="enemiesLeft">' + (document.getElementById('enemiesLeft')?.textContent || '5') + '</span>';
            document.getElementById('gun-level-label').innerHTML = t.gunLevel + ': <span id="gunLevel">' + (document.getElementById('gunLevel')?.textContent || '1') + '</span>';
            document.getElementById('turret-strength-label').innerHTML = t.turretStrength + ': <span id="turretStrength">' + (document.getElementById('turretStrength')?.textContent || '1') + '</span>';
            document.getElementById('balloon-strength-label').innerHTML = t.balloonStrength + ': <span id="balloonStrength">' + (document.getElementById('balloonStrength')?.textContent || '1') + '</span>';
            document.getElementById('final-coins-label').innerHTML = t.finalCoins + ': <span id="finalCoins">' + (document.getElementById('finalCoins')?.textContent || '0') + '</span>';
            document.getElementById('waves-survived-label').innerHTML = t.wavesSurvived + ': <span id="finalWave">' + (document.getElementById('finalWave')?.textContent || '0') + '</span>';
            
            // Update cost labels using their IDs
            document.getElementById('gun-cost-label').innerHTML = t.cost + ': <span id="gunCost">' + (document.getElementById('gunCost')?.textContent || '50') + '</span>';
            document.getElementById('house-cost-label').innerHTML = t.cost + ': <span id="houseCost">' + (document.getElementById('houseCost')?.textContent || '30') + '</span>';
            document.getElementById('turret-cost-label').innerHTML = t.cost + ': <span id="turretCost">' + (document.getElementById('turretCost')?.textContent || '100') + '</span>';
            document.getElementById('repair-cost-label').innerHTML = t.cost + ': <span id="repairCost">' + (document.getElementById('repairCost')?.textContent || '20') + '</span>';
            
            // Update credit label
            document.getElementById('creditLabel').textContent = t.creditLabel;
        }
        
        let selectedDifficulty = 'normal';
        let game;
        
        // Initialize language buttons
        updateLanguageButtons();
        
        // Set up startup popup event listeners immediately
        document.getElementById('easyStart').addEventListener('click', () => startGame('easy'));
        document.getElementById('normalStart').addEventListener('click', () => startGame('normal'));
        document.getElementById('hardStart').addEventListener('click', () => startGame('hard'));
        document.getElementById('restartBtn').addEventListener('click', showStartupPopup);
        
        function startGame(difficulty) {
            selectedDifficulty = difficulty;
            document.getElementById('difficultyPopup').style.display = 'none';
            game = new Game();
        }
        
        function showStartupPopup() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('shop').style.display = 'none';
            document.getElementById('difficultyMenu').style.display = 'none';
            document.getElementById('difficultyPopup').style.display = 'block';
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameContainer = document.getElementById('gameContainer');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    if (this.gameStarted) {
                        this.repositionGameElements();
                    }
                });
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.resizeCanvas();
                        if (this.gameStarted) {
                            this.repositionGameElements();
                        }
                    }, 100);
                });
                
                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            resizeCanvas() {
                // Get viewport dimensions - use document.documentElement for more reliable sizing
                const viewportWidth = Math.max(
                    document.documentElement.clientWidth || 0,
                    window.innerWidth || 0
                );
                const viewportHeight = Math.max(
                    document.documentElement.clientHeight || 0, 
                    window.innerHeight || 0
                );
                
                // Always use full viewport for better responsiveness
                const canvasWidth = viewportWidth;
                const canvasHeight = viewportHeight - (viewportHeight * 0.1);
                
                // Set canvas dimensions (internal resolution)
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                this.width = canvasWidth;
                this.height = canvasHeight;
                
                // Set canvas display size (CSS size)
                this.canvas.style.width = canvasWidth + 'px';
                this.canvas.style.height = canvasHeight + 'px';
                
                // Log dimensions for debugging
                console.log(`Canvas resized to: ${canvasWidth}x${canvasHeight}`);
            }
            
            repositionGameElements() {
                // Recalculate positions based on new dimensions
                if (this.player) {
                    this.player.x = this.width * 0.14;
                    this.player.y = this.height * 0.5;
                }
                
                if (this.house) {
                    this.house.x = this.width * 0.05;
                    this.house.y = this.height * 0.55;
                    this.house.width = this.width * 0.18;
                    this.house.height = this.height * 0.45;
                }
                
                if (this.wall) {
                    this.wall.x = this.house.x + this.house.width + 15;
                    this.wall.y = this.height * 0.70;
                    this.wall.width = 25;
                    this.wall.height = this.height * 0.30;
                }
                
                // Position game buttons to align with house/wall bottom
                const gameButtons = document.getElementById('gameButtons');
                if (gameButtons && this.wall) {
                    // Wall bottom is at wall.y + wall.height
                    const wallBottom = this.wall.y + this.wall.height;
                    // Convert canvas coordinates to screen pixels and add some padding
                    gameButtons.style.bottom = (this.height - wallBottom + 20) + 'px';
                }
            }
            
            updateDynamicTranslations() {
                // Update shop button text if shop is open
                if (document.getElementById('shop').style.display !== 'none') {
                    if (this.turrets.length >= 3) {
                        document.getElementById('turret-button-text').textContent = t.upgradeTurrets;
                    } else {
                        document.getElementById('turret-button-text').textContent = t.buyTurret;
                    }
                    
                    // Update cost labels using IDs
                    document.getElementById('gun-cost-label').innerHTML = t.cost + ': <span id="gunCost">' + document.getElementById('gunCost').textContent + '</span>';
                    document.getElementById('house-cost-label').innerHTML = t.cost + ': <span id="houseCost">' + document.getElementById('houseCost').textContent + '</span>';
                    document.getElementById('turret-cost-label').innerHTML = t.cost + ': <span id="turretCost">' + document.getElementById('turretCost').textContent + '</span>';
                    document.getElementById('repair-cost-label').innerHTML = t.cost + ': <span id="repairCost">' + document.getElementById('repairCost').textContent + '</span>';
                }
            }
            
            init() {
                this.coins = 0;
                this.wave = 1;
                this.houseHP = 25;
                this.maxHouseHP = 25;
                this.gameRunning = true;
                this.waveActive = false;
                this.paused = false;
                this.difficulty = selectedDifficulty;
                this.placingTurret = false;
                
                this.player = {
                    x: this.width * 0.14,
                    y: this.height * 0.5,
                    gunLevel: 1,
                    gunDamage: 1,
                    fireRate: 300,
                    lastShot: 0,
                    size: 20
                };
                
                this.house = {
                    x: this.width * 0.05,
                    y: this.height * 0.55,
                    width: this.width * 0.18,
                    height: this.height * 0.45,
                    armor: 0
                };
                
                this.wall = {
                    x: this.house.x + this.house.width + 15,
                    y: this.height * 0.70,  // Moved up to accommodate 20% height increase
                    width: 25,
                    height: this.height * 0.30  // Increased by 20% (from 0.25 to 0.30)
                };
                
                this.balloons = [];
                this.bullets = [];
                this.turrets = [];
                this.particles = [];
                this.coinParticles = [];
                
                // Turret upgrade properties
                this.turretStrength = 1;
                this.turretUpgradeCost = 300;
                
                this.generateRandomVegetation();
                
                this.enemiesInWave = this.getEnemiesPerWave();
                this.enemiesSpawned = 0;
                this.lastSpawn = 0;
                this.spawnRate = this.getSpawnRate();
                
                this.upgradeCosts = {
                    gun: 50,
                    house: 30,
                    turret: 75,
                    repair: 20
                };
                
                // Position UI elements based on game elements
                this.repositionGameElements();
                
                this.startWave();
            }
            
            generateRandomVegetation() {
                this.treePositions = [];
                const numTrees = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numTrees; i++) {
                    const x = this.width * (0.5 + Math.random() * 0.45);
                    const y = this.height * (0.6 + Math.random() * 0.25);
                    this.treePositions.push({ x, y });
                }
                
                this.bushPositions = [];
                const numBushes = 3 + Math.floor(Math.random() * 4);
                
                for (let i = 0; i < numBushes; i++) {
                    const x = this.width * (0.4 + Math.random() * 0.55);
                    const y = this.height * (0.8 + Math.random() * 0.15);
                    this.bushPositions.push({ x, y });
                }
            }
            
            // Helper function to darken a color
            darkenColor(color, factor) {
                // Convert hex to RGB if needed
                let r, g, b;
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                } else if (color.startsWith('rgb')) {
                    const match = color.match(/\d+/g);
                    r = parseInt(match[0]);
                    g = parseInt(match[1]);
                    b = parseInt(match[2]);
                } else {
                    // Handle named colors
                    const namedColors = {
                        '#FF6B6B': [255, 107, 107],
                        '#4ECDC4': [78, 205, 196],
                        '#45B7D1': [69, 183, 209],
                        '#9B59B6': [155, 89, 182],
                        '#F39C12': [243, 156, 18]
                    };
                    if (namedColors[color]) {
                        [r, g, b] = namedColors[color];
                    } else {
                        return color; // Fallback to original color
                    }
                }
                
                // Darken the color
                r = Math.floor(r * (1 - factor));
                g = Math.floor(g * (1 - factor));
                b = Math.floor(b * (1 - factor));
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            // Helper function to lighten a color
            lightenColor(color, factor) {
                // Convert hex to RGB if needed
                let r, g, b;
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                } else if (color.startsWith('rgb')) {
                    const match = color.match(/\d+/g);
                    r = parseInt(match[0]);
                    g = parseInt(match[1]);
                    b = parseInt(match[2]);
                } else {
                    // Handle named colors
                    const namedColors = {
                        '#FF6B6B': [255, 107, 107],
                        '#4ECDC4': [78, 205, 196],
                        '#45B7D1': [69, 183, 209],
                        '#9B59B6': [155, 89, 182],
                        '#F39C12': [243, 156, 18]
                    };
                    if (namedColors[color]) {
                        [r, g, b] = namedColors[color];
                    } else {
                        return color; // Fallback to original color
                    }
                }
                
                // Lighten the color
                r = Math.min(255, Math.floor(r + (255 - r) * factor));
                g = Math.min(255, Math.floor(g + (255 - g) * factor));
                b = Math.min(255, Math.floor(b + (255 - b) * factor));
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
                
                document.getElementById('upgradeGun').addEventListener('click', () => this.upgradeGun());
                document.getElementById('reinforceHouse').addEventListener('click', () => this.reinforceHouse());
                document.getElementById('buyTurret').addEventListener('click', () => this.buyTurret());
                document.getElementById('repairHouse').addEventListener('click', () => this.repairHouse());
                document.getElementById('closeShop').addEventListener('click', () => this.closeShop());
                
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('difficultyBtn').addEventListener('click', () => this.showDifficultyMenu());
                // document.getElementById('donateBtn').addEventListener('click', () => this.showDonateMessage());
                
                document.getElementById('easyBtn').addEventListener('click', () => this.setDifficulty('easy'));
                document.getElementById('normalBtn').addEventListener('click', () => this.setDifficulty('normal'));
                document.getElementById('hardBtn').addEventListener('click', () => this.setDifficulty('hard'));
                document.getElementById('closeDifficultyBtn').addEventListener('click', () => this.hideDifficultyMenu());
            }
            
            handleClick(e) {
                if (!this.gameRunning || this.paused) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.placingTurret) {
                    this.placeTurret(x, y);
                } else {
                    this.shoot(x, y);
                }
            }
            
            handleTouch(e) {
                e.preventDefault();
                if (!this.gameRunning || this.paused) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                if (this.placingTurret) {
                    this.placeTurret(x, y);
                } else {
                    this.shoot(x, y);
                }
            }
            
            handleMouseMove(e) {
                const crosshair = document.getElementById('crosshair');
                const rect = this.canvas.getBoundingClientRect();
                const containerRect = this.gameContainer.getBoundingClientRect();
                
                // Show custom crosshair and hide default cursor
                crosshair.style.display = 'block';
                this.gameContainer.classList.add('hide-cursor');
                
                crosshair.style.left = (e.clientX - containerRect.left - 15) + 'px';
                crosshair.style.top = (e.clientY - containerRect.top - 15) + 'px';
                
                this.mouseX = e.clientX - rect.left;
                this.mouseY = e.clientY - rect.top;
            }
            
            handleMouseLeave() {
                const crosshair = document.getElementById('crosshair');
                crosshair.style.display = 'none';
                this.gameContainer.classList.remove('hide-cursor');
            }
            
            shoot(targetX, targetY) {
                const now = Date.now();
                if (now - this.player.lastShot < this.player.fireRate) return;
                
                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                const angle = Math.atan2(dy, dx);
                
                this.bullets.push({
                    x: this.player.x,
                    y: this.player.y,
                    vx: Math.cos(angle) * 16,
                    vy: Math.sin(angle) * 16,
                    damage: this.player.gunDamage
                });
                
                this.player.lastShot = now;
                
                for (let i = 0; i < 5; i++) {
                    this.particles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 10,
                        color: `hsl(${Math.random() * 60 + 10}, 100%, 60%)`
                    });
                }
            }
            
            startWave() {
                this.waveActive = true;
                this.enemiesSpawned = 0;
                this.enemiesInWave = this.getEnemiesPerWave();
                this.spawnRate = this.getSpawnRate();
                this.lastSpawn = Date.now();
                
                document.getElementById('enemiesLeft').textContent = this.enemiesInWave;
            }
            
            getEnemiesPerWave() {
                const baseEnemies = 5 + this.wave * 2;
                switch (this.difficulty) {
                    case 'easy': return Math.max(3, Math.floor(baseEnemies * 0.7));
                    case 'normal': return baseEnemies;
                    case 'hard': return Math.floor(baseEnemies * 1.5);
                    default: return baseEnemies;
                }
            }
            
            getSpawnRate() {
                const baseRate = Math.max(800, 2000 - this.wave * 100);
                switch (this.difficulty) {
                    case 'easy': return baseRate * 1.3;
                    case 'normal': return baseRate;
                    case 'hard': return baseRate * 0.6;
                    default: return baseRate;
                }
            }
            
            spawnBalloon() {
                if (this.enemiesSpawned >= this.enemiesInWave) return;
                
                const types = ['basic', 'armored', 'heavy', 'giant', 'speed', 'superarmored', 'stealth'];
                let weights;
                
                switch (this.difficulty) {
                    case 'easy': weights = [0.6, 0.2, 0.1, 0.05, 0.05, 0, 0]; break;
                    case 'normal': weights = [0.4, 0.2, 0.15, 0.1, 0.1, 0.03, 0.02]; break;
                    case 'hard': weights = [0.2, 0.15, 0.2, 0.15, 0.1, 0.1, 0.1]; break;
                    default: weights = [0.4, 0.2, 0.15, 0.1, 0.1, 0.03, 0.02];
                }
                
                if (this.wave >= 3) {
                    weights[3] += 0.05;
                    weights[0] -= 0.05;
                    // Start spawning super armored balloons
                    if (weights[5] === 0) weights[5] = 0.05;
                }
                if (this.wave >= 5) {
                    weights[4] += 0.1;
                    weights[0] -= 0.1;
                    // Increase super armored and stealth spawns
                    weights[5] += 0.05;
                    weights[6] += 0.05;
                    weights[1] -= 0.05;
                }
                
                let type = 'basic';
                const rand = Math.random();
                let cumulative = 0;
                for (let i = 0; i < types.length; i++) {
                    cumulative += weights[i];
                    if (rand <= cumulative) {
                        type = types[i];
                        break;
                    }
                }
                
                let hp, points, color, size, speed;
                switch (type) {
                    case 'basic': hp = 1; points = 1; color = '#FF6B6B'; size = 30; speed = 1; break;
                    case 'armored': hp = 2; points = 2; color = '#4ECDC4'; size = 35; speed = 0.8; break;
                    case 'heavy': hp = 3; points = 3; color = '#45B7D1'; size = 40; speed = 0.6; break;
                    case 'giant': hp = 5; points = 5; color = '#9B59B6'; size = 55; speed = 0.4; break;
                    case 'speed': hp = 1; points = 3; color = '#F39C12'; size = 25; speed = 2; break;
                    case 'superarmored': hp = 4; points = 4; color = '#2C3E50'; size = 38; speed = 1.2; break;
                    case 'stealth': hp = 2; points = 4; color = '#95A5A6'; size = 28; speed = 1.5; break;
                }
                
                let difficultyMultiplier = 1;
                switch (this.difficulty) {
                    case 'easy': difficultyMultiplier = 0.8; break;
                    case 'normal': difficultyMultiplier = 1; break;
                    case 'hard': 
                        difficultyMultiplier = 1.2;
                        if (Math.random() < 0.3) difficultyMultiplier *= 1.5;
                        break;
                }
                
                const finalSpeed = speed * difficultyMultiplier;
                
                // Calculate balloon strength multiplier based on wave and difficulty
                // Multiplier increases every 10 waves with different rates per difficulty
                const waveMultiplierLevel = Math.floor(this.wave / 10);
                let strengthIncrease;
                switch (this.difficulty) {
                    case 'easy': strengthIncrease = 1.5; break;    // 50% increase per 10 waves
                    case 'normal': strengthIncrease = 1.75; break; // 75% increase per 10 waves
                    case 'hard': strengthIncrease = 2.0; break;    // 100% increase per 10 waves (double)
                    default: strengthIncrease = 1.75;
                }
                const balloonStrength = Math.pow(strengthIncrease, waveMultiplierLevel);
                const finalHP = hp * balloonStrength;
                
                this.balloons.push({
                    x: this.width + 50,
                    y: Math.random() * (this.height * 0.6) + 50,
                    vx: -(finalSpeed + this.wave * 0.2 + Math.random() * 0.5),
                    vy: (Math.random() - 0.5) * 0.5,
                    hp: finalHP, maxHP: finalHP, points, color, size, type,
                    speed: finalSpeed,
                    hasSpeedBoost: difficultyMultiplier > 1.2
                });
                
                this.enemiesSpawned++;
            }
            
            update() {
                if (!this.gameRunning || this.paused) return;
                
                const now = Date.now();
                
                if (this.waveActive && now - this.lastSpawn > this.spawnRate) {
                    this.spawnBalloon();
                    this.lastSpawn = now;
                }
                
                for (let i = this.balloons.length - 1; i >= 0; i--) {
                    const balloon = this.balloons[i];
                    balloon.x += balloon.vx;
                    balloon.y += balloon.vy;
                    
                    if (balloon.y <= 0 || balloon.y >= this.height * 0.6) {
                        balloon.vy *= -1;
                    }
                    
                    if (balloon.x <= this.wall.x + this.wall.width + balloon.size) {
                        this.houseHP -= Math.max(1, balloon.points - this.house.armor);
                        this.balloons.splice(i, 1);
                        
                        for (let j = 0; j < 10; j++) {
                            this.particles.push({
                                x: this.wall.x + this.wall.width,
                                y: this.wall.y + this.wall.height * 0.5,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 20,
                                color: '#8B4513'
                            });
                        }
                        
                        if (this.houseHP <= 0) {
                            this.gameOver();
                            return;
                        }
                        continue;
                    }
                }
                
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    if (bullet.x > this.width || bullet.x < 0 || bullet.y > this.height || bullet.y < 0) {
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    for (let j = this.balloons.length - 1; j >= 0; j--) {
                        const balloon = this.balloons[j];
                        const dx = bullet.x - balloon.x;
                        const dy = bullet.y - balloon.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < balloon.size) {
                            balloon.hp -= bullet.damage;
                            this.bullets.splice(i, 1);
                            
                            for (let k = 0; k < 8; k++) {
                                this.particles.push({
                                    x: balloon.x, y: balloon.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 15, color: balloon.color
                                });
                            }
                            
                            if (balloon.hp <= 0) {
                                this.coins += balloon.points;
                                
                                for (let k = 0; k < balloon.points * 2; k++) {
                                    this.coinParticles.push({
                                        x: balloon.x, y: balloon.y,
                                        vx: (Math.random() - 0.5) * 6,
                                        vy: (Math.random() - 0.5) * 6 - 2,
                                        life: 40, value: 1, gravity: 0.1
                                    });
                                }
                                
                                this.balloons.splice(j, 1);
                                
                                for (let k = 0; k < 15; k++) {
                                    this.particles.push({
                                        x: balloon.x, y: balloon.y,
                                        vx: (Math.random() - 0.5) * 8,
                                        vy: (Math.random() - 0.5) * 8,
                                        life: 25, color: balloon.color
                                    });
                                }
                            }
                            break;
                        }
                    }
                }
                
                for (const turret of this.turrets) {
                    if (now - turret.lastShot > turret.fireRate) {
                        const nearestBalloon = this.findNearestBalloon(turret.x, turret.y);
                        if (nearestBalloon) {
                            const dx = nearestBalloon.x - turret.x;
                            const dy = nearestBalloon.y - turret.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < turret.range) {
                                const angle = Math.atan2(dy, dx);
                                // Apply turret strength multiplier (50% increase per level)
                                const turretDamage = turret.damage * Math.pow(1.5, this.turretStrength - 1);
                                this.bullets.push({
                                    x: turret.x, y: turret.y,
                                    vx: Math.cos(angle) * 12,
                                    vy: Math.sin(angle) * 12,
                                    damage: turretDamage
                                });
                                turret.lastShot = now;
                            }
                        }
                    }
                }
                
                for (let i = this.coinParticles.length - 1; i >= 0; i--) {
                    const coin = this.coinParticles[i];
                    coin.x += coin.vx;
                    coin.y += coin.vy;
                    coin.vy += coin.gravity;
                    coin.vx *= 0.98;
                    coin.life--;
                    
                    if (coin.life <= 0) {
                        this.coinParticles.splice(i, 1);
                    }
                }
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                if (this.waveActive && this.balloons.length === 0 && this.enemiesSpawned >= this.enemiesInWave) {
                    this.waveComplete();
                }
                
                this.updateUI();
            }
            
            findNearestBalloon(x, y) {
                let nearest = null;
                let minDistance = Infinity;
                
                for (const balloon of this.balloons) {
                    const dx = balloon.x - x;
                    const dy = balloon.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = balloon;
                    }
                }
                
                return nearest;
            }
            
            waveComplete() {
                this.waveActive = false;
                this.wave++;
                // Add 1 second delay before showing the shop
                setTimeout(() => {
                    this.showShop();
                }, 1000);
            }
            
            showShop() {
                document.getElementById('shop').style.display = 'block';
                document.getElementById('shopCoins').textContent = this.coins;
                this.updateShopButtons();
            }
            
            updateShopButtons() {
                const gunBtn = document.getElementById('upgradeGun');
                const houseBtn = document.getElementById('reinforceHouse');
                const turretBtn = document.getElementById('buyTurret');
                const repairBtn = document.getElementById('repairHouse');
                
                gunBtn.disabled = this.coins < this.upgradeCosts.gun;
                houseBtn.disabled = this.coins < this.upgradeCosts.house;
                
                // Change turret button to upgrade turrets when player has 3 turrets
                if (this.turrets.length >= 3) {
                    // Show "Upgrade Turrets" button
                    turretBtn.style.display = 'block';
                    document.getElementById('turret-button-text').textContent = t.upgradeTurrets;
                    turretBtn.disabled = this.coins < this.turretUpgradeCost;
                    document.getElementById('turretCost').textContent = this.turretUpgradeCost;
                } else {
                    // Show "Buy Turret" button
                    turretBtn.style.display = 'block';
                    document.getElementById('turret-button-text').textContent = t.buyTurret;
                    turretBtn.disabled = this.coins < this.upgradeCosts.turret;
                    document.getElementById('turretCost').textContent = this.upgradeCosts.turret;
                }
                
                repairBtn.disabled = this.coins < this.upgradeCosts.repair || this.houseHP >= this.maxHouseHP;
                
                document.getElementById('gunCost').textContent = this.upgradeCosts.gun;
                document.getElementById('houseCost').textContent = this.upgradeCosts.house;
                document.getElementById('repairCost').textContent = this.upgradeCosts.repair;
            }
            
            upgradeGun() {
                if (this.coins >= this.upgradeCosts.gun) {
                    this.coins -= this.upgradeCosts.gun;
                    this.player.gunLevel++;
                    this.player.gunDamage = this.player.gunLevel;
                    this.player.fireRate = Math.max(100, 300 - this.player.gunLevel * 20);
                    this.upgradeCosts.gun = Math.floor(this.upgradeCosts.gun * 1.5);
                    this.updateShopButtons();
                }
            }
            
            reinforceHouse() {
                if (this.coins >= this.upgradeCosts.house) {
                    this.coins -= this.upgradeCosts.house;
                    this.house.armor++;
                    this.maxHouseHP += 20;
                    this.houseHP += 20;
                    this.upgradeCosts.house = Math.floor(this.upgradeCosts.house * 1.3);
                    this.updateShopButtons();
                }
            }
            
            buyTurret() {
                if (this.turrets.length >= 3) {
                    // Upgrade turrets
                    if (this.coins >= this.turretUpgradeCost) {
                        this.coins -= this.turretUpgradeCost;
                        this.turretStrength++;
                        this.turretUpgradeCost = Math.floor(this.turretUpgradeCost * 1.5);
                        this.updateShopButtons();
                    }
                } else {
                    // Buy new turret
                    if (this.coins >= this.upgradeCosts.turret) {
                        this.coins -= this.upgradeCosts.turret;
                        this.placingTurret = true;
                        document.getElementById('shop').style.display = 'none';
                        this.upgradeCosts.turret = Math.floor(this.upgradeCosts.turret * 1.4);
                    }
                }
            }
            
            placeTurret(x, y) {
                if (!this.placingTurret) return;
                
                const lineX = this.wall.x + this.wall.width + 20;
                const originalHeight = this.height - 20 - (this.wall.y + 10);
                const newHeight = originalHeight * 4.375;
                const lineStartY = this.wall.y + 10 - (newHeight - originalHeight);
                const lineEndY = this.height - 20;
                
                if (Math.abs(x - lineX) <= 30 && y >= lineStartY && y <= lineEndY) {
                    this.turrets.push({
                        x: lineX, y: y, damage: 1, level: 1,
                        range: 300, fireRate: 500, lastShot: 0
                    });
                    
                    this.placingTurret = false;
                    this.showShop();
                }
            }
            
            repairHouse() {
                if (this.coins >= this.upgradeCosts.repair && this.houseHP < this.maxHouseHP) {
                    this.coins -= this.upgradeCosts.repair;
                    this.houseHP = Math.min(this.maxHouseHP, this.houseHP + 30);
                    this.updateShopButtons();
                }
            }
            
            closeShop() {
                document.getElementById('shop').style.display = 'none';
                this.startWave();
            }
            
            togglePause() {
                this.paused = !this.paused;
                document.getElementById('pauseBtn').textContent = this.paused ? t.resume : t.pause;
            }
            
            showDifficultyMenu() {
                // Update button selection state before showing menu
                document.querySelectorAll('.difficulty-menu button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                document.getElementById(this.difficulty + 'Btn').classList.add('selected');
                
                document.getElementById('difficultyMenu').style.display = 'block';
            }
            
            hideDifficultyMenu() {
                document.getElementById('difficultyMenu').style.display = 'none';
            }
            
            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                
                document.querySelectorAll('.difficulty-menu button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                document.getElementById(difficulty + 'Btn').classList.add('selected');
                
                this.hideDifficultyMenu();
                
                // Only auto-start wave if shop is not open
                const shopOpen = document.getElementById('shop').style.display === 'block';
                if (this.gameRunning && !this.waveActive && !shopOpen) {
                    this.startWave();
                }
            }
            
            showDonateMessage() {
                alert('Thank you for your interest in supporting the game!\n\nThis feature would connect to a donation platform in a real game.');
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawGroundDecoration();
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 200 + Date.now() * 0.02) % (this.width + 100);
                    const y = 50 + i * 30;
                    this.drawCloud(x, y);
                }
                
                this.drawHouse();
                this.drawWall();
                this.drawPlayer();
                
                for (let i = 0; i < this.turrets.length; i++) {
                    this.drawTurret(this.turrets[i], i + 1);
                }
                
                if (this.placingTurret) {
                    this.drawTurretPlacementLine();
                    this.drawTurretPlacementPreview();
                }
                
                for (const balloon of this.balloons) {
                    this.drawBalloon(balloon);
                }
                
                this.ctx.fillStyle = '#9B59B6';
                for (const bullet of this.bullets) {
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'rgba(155, 89, 182, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x - bullet.vx * 0.5, bullet.y - bullet.vy * 0.5, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#9B59B6';
                }
                
                for (const coin of this.coinParticles) {
                    this.ctx.globalAlpha = coin.life / 40;
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(coin.x, coin.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.beginPath();
                    this.ctx.arc(coin.x - 1, coin.y - 1, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                for (const particle of this.particles) {
                    this.ctx.globalAlpha = particle.life / 25;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                // Draw dark overlay when paused
                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    
                    // Draw pause text
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('PAUSED', this.width / 2, this.height / 2);
                    
                    this.ctx.font = '24px Arial';
                    this.ctx.fillText(t.resume + ' to continue', this.width / 2, this.height / 2 + 60);
                }
            }
            
            drawGroundDecoration() {
                for (const tree of this.treePositions) {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(tree.x - 6, tree.y, 12, this.height - tree.y);
                    
                    this.ctx.fillStyle = '#228B22';
                    this.ctx.beginPath();
                    this.ctx.arc(tree.x, tree.y - 8, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(tree.x - 15, tree.y + 8, 18, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(tree.x + 15, tree.y + 4, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                for (const bush of this.bushPositions) {
                    this.ctx.fillStyle = '#32CD32';
                    this.ctx.beginPath();
                    this.ctx.arc(bush.x - 10, bush.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(bush.x, bush.y - 3, 12, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(bush.x + 10, bush.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawCloud(x, y) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, 20, 0, Math.PI * 2);
                this.ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
                this.ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawHouse() {
                // Colorful house walls with bright gradient
                const wallGradient = this.ctx.createLinearGradient(
                    this.house.x, this.house.y,
                    this.house.x, this.house.y + this.house.height
                );
                wallGradient.addColorStop(0, '#FFE4B5');  // Peach/cream top
                wallGradient.addColorStop(0.5, '#FFDAB9'); // Lighter peach
                wallGradient.addColorStop(1, '#FFB6C1');   // Light pink bottom
                
                this.ctx.fillStyle = wallGradient;
                this.ctx.fillRect(this.house.x, this.house.y, this.house.width, this.house.height);
                
                // Add polka dots pattern for childish look
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let x = 0; x < this.house.width - 30; x += 30) {
                    for (let y = 0; y < this.house.height; y += 30) {
                        this.ctx.beginPath();
                        this.ctx.arc(this.house.x + x + 15, this.house.y + y + 15, 5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                // Colorful roof with bright red gradient
                const roofGradient = this.ctx.createLinearGradient(
                    this.house.x + this.house.width / 2, this.house.y - 65,
                    this.house.x + this.house.width / 2, this.house.y
                );
                roofGradient.addColorStop(0, '#FF6B6B');  // Bright red top
                roofGradient.addColorStop(0.5, '#FF5252'); // Medium red
                roofGradient.addColorStop(1, '#D32F2F');   // Darker red bottom
                
                this.ctx.fillStyle = roofGradient;
                this.ctx.beginPath();
                this.ctx.moveTo(this.house.x - 30, this.house.y);
                this.ctx.lineTo(this.house.x + this.house.width + 30, this.house.y);
                this.ctx.lineTo(this.house.x + this.house.width / 2, this.house.y - 70);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Thick cartoon roof outline
                this.ctx.strokeStyle = '#8B0000';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(this.house.x - 30, this.house.y);
                this.ctx.lineTo(this.house.x + this.house.width / 2, this.house.y - 70);
                this.ctx.lineTo(this.house.x + this.house.width + 30, this.house.y);
                this.ctx.stroke();
                
                // Cartoon windows with shutters
                const windowPositions = [
                    { x: this.house.x + 20, y: this.house.y + 30 },
                    { x: this.house.x + this.house.width - 55, y: this.house.y + 30 },
                    { x: this.house.x + 20, y: this.house.y + 100 },
                    { x: this.house.x + this.house.width - 55, y: this.house.y + 100 }
                ];
                
                windowPositions.forEach((window, index) => {
                    // Window shutters (alternating colors)
                    const shutterColor = index % 2 === 0 ? '#4CAF50' : '#2196F3';
                    this.ctx.fillStyle = shutterColor;
                    this.ctx.fillRect(window.x - 8, window.y - 2, 6, 39);
                    this.ctx.fillRect(window.x + 37, window.y - 2, 6, 39);
                    
                    // Window frame
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(window.x - 2, window.y - 2, 39, 39);
                    
                    // Window glass with sky blue gradient
                    const glassGradient = this.ctx.createLinearGradient(
                        window.x, window.y,
                        window.x, window.y + 35
                    );
                    glassGradient.addColorStop(0, '#87CEEB');
                    glassGradient.addColorStop(1, '#E0F7FA');
                    
                    this.ctx.fillStyle = glassGradient;
                    this.ctx.fillRect(window.x, window.y, 35, 35);
                    
                    // Cartoon window panes (cross pattern)
                    this.ctx.strokeStyle = '#654321';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(window.x + 17.5, window.y);
                    this.ctx.lineTo(window.x + 17.5, window.y + 35);
                    this.ctx.moveTo(window.x, window.y + 17.5);
                    this.ctx.lineTo(window.x + 35, window.y + 17.5);
                    this.ctx.stroke();
                    
                    // Cute curtains visible through window
                    this.ctx.fillStyle = 'rgba(255, 192, 203, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(window.x + 2, window.y + 2);
                    this.ctx.quadraticCurveTo(window.x + 8, window.y + 8, window.x + 2, window.y + 20);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.moveTo(window.x + 33, window.y + 2);
                    this.ctx.quadraticCurveTo(window.x + 27, window.y + 8, window.x + 33, window.y + 20);
                    this.ctx.fill();
                });
                
                // Colorful arched door
                const doorX = this.house.x + this.house.width / 2 - 20;
                const doorY = this.house.y + this.house.height - 75;
                
                // Door frame with rounded top
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(doorX - 3, doorY, 46, 75);
                this.ctx.beginPath();
                this.ctx.arc(doorX + 20, doorY, 23, Math.PI, 0, false);
                this.ctx.fill();
                
                // Bright door
                const doorGradient = this.ctx.createLinearGradient(
                    doorX, doorY,
                    doorX + 40, doorY
                );
                doorGradient.addColorStop(0, '#FFD700');  // Gold
                doorGradient.addColorStop(0.5, '#FFA500'); // Orange
                doorGradient.addColorStop(1, '#FFD700');   // Gold
                
                this.ctx.fillStyle = doorGradient;
                this.ctx.fillRect(doorX, doorY + 5, 40, 70);
                this.ctx.beginPath();
                this.ctx.arc(doorX + 20, doorY + 5, 20, Math.PI, 0, false);
                this.ctx.fill();
                
                // Door window (heart shape)
                this.ctx.fillStyle = 'rgba(135, 206, 235, 0.7)';
                const heartX = doorX + 20;
                const heartY = doorY + 15;
                this.ctx.beginPath();
                this.ctx.moveTo(heartX, heartY + 5);
                this.ctx.bezierCurveTo(heartX, heartY, heartX - 8, heartY, heartX - 8, heartY + 5);
                this.ctx.bezierCurveTo(heartX - 8, heartY + 10, heartX, heartY + 15, heartX, heartY + 20);
                this.ctx.bezierCurveTo(heartX, heartY + 15, heartX + 8, heartY + 10, heartX + 8, heartY + 5);
                this.ctx.bezierCurveTo(heartX + 8, heartY, heartX, heartY, heartX, heartY + 5);
                this.ctx.fill();
                
                // Round door knob
                this.ctx.fillStyle = '#FF69B4';
                this.ctx.beginPath();
                this.ctx.arc(doorX + 32, doorY + 40, 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.strokeStyle = '#FF1493';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Colorful chimney with smoke
                const chimneyX = this.house.x + this.house.width * 0.75;
                const chimneyGradient = this.ctx.createLinearGradient(
                    chimneyX, this.house.y - 45,
                    chimneyX + 30, this.house.y - 45
                );
                chimneyGradient.addColorStop(0, '#DC143C');
                chimneyGradient.addColorStop(0.5, '#FF6347');
                chimneyGradient.addColorStop(1, '#DC143C');
                
                this.ctx.fillStyle = chimneyGradient;
                this.ctx.fillRect(chimneyX, this.house.y - 50, 30, 50);
                
                // Chimney top with stripes
                this.ctx.fillStyle = '#8B0000';
                this.ctx.fillRect(chimneyX - 4, this.house.y - 54, 38, 8);
                
                // Add smoke puffs
                const time = Date.now() / 1000;
                for (let i = 0; i < 3; i++) {
                    const smokeY = this.house.y - 54 - (i * 15) - (time % 3) * 10;
                    const smokeX = chimneyX + 15 + Math.sin(time + i) * 5;
                    const smokeSize = 8 + i * 2;
                    
                    this.ctx.fillStyle = `rgba(200, 200, 200, ${0.5 - i * 0.15})`;
                    this.ctx.beginPath();
                    this.ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Add decorative flowers around house base
                const flowerColors = ['#FF69B4', '#FFD700', '#00CED1', '#FF6347', '#9370DB'];
                for (let i = 0; i < 8; i++) {
                    const flowerX = this.house.x - 10 + (i * (this.house.width + 20) / 7);
                    const flowerY = this.house.y + this.house.height - 5;
                    
                    // Stem
                    this.ctx.strokeStyle = '#228B22';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(flowerX, flowerY);
                    this.ctx.lineTo(flowerX, flowerY - 15);
                    this.ctx.stroke();
                    
                    // Flower petals
                    this.ctx.fillStyle = flowerColors[i % flowerColors.length];
                    for (let j = 0; j < 5; j++) {
                        const angle = (j * Math.PI * 2) / 5;
                        const petalX = flowerX + Math.cos(angle) * 5;
                        const petalY = flowerY - 15 + Math.sin(angle) * 5;
                        this.ctx.beginPath();
                        this.ctx.arc(petalX, petalY, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Flower center
                    this.ctx.fillStyle = '#FFFF00';
                    this.ctx.beginPath();
                    this.ctx.arc(flowerX, flowerY - 15, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // HP Bar with gradient
                const hpBarWidth = this.house.width;
                const hpPercentage = this.houseHP / this.maxHouseHP;
                
                // HP bar background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(this.house.x - 2, this.house.y - 27, hpBarWidth + 4, 16);
                
                // HP bar gradient
                const hpGradient = this.ctx.createLinearGradient(
                    this.house.x, this.house.y - 25,
                    this.house.x, this.house.y - 13
                );
                if (hpPercentage > 0.5) {
                    hpGradient.addColorStop(0, '#00FF00');
                    hpGradient.addColorStop(1, '#00AA00');
                } else if (hpPercentage > 0.25) {
                    hpGradient.addColorStop(0, '#FFFF00');
                    hpGradient.addColorStop(1, '#AAAA00');
                } else {
                    hpGradient.addColorStop(0, '#FF0000');
                    hpGradient.addColorStop(1, '#AA0000');
                }
                
                this.ctx.fillStyle = hpGradient;
                this.ctx.fillRect(this.house.x, this.house.y - 25, hpBarWidth * hpPercentage, 12);
                
                // HP bar border
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(this.house.x, this.house.y - 25, hpBarWidth, 12);
            }
            
            drawWall() {
                // 3D Metallic fortified wall
                const wallGradient = this.ctx.createLinearGradient(
                    this.wall.x, this.wall.y,
                    this.wall.x + this.wall.width, this.wall.y + this.wall.height
                );
                wallGradient.addColorStop(0, '#8A8A8A');
                wallGradient.addColorStop(0.2, '#707070');
                wallGradient.addColorStop(0.5, '#606060');
                wallGradient.addColorStop(0.8, '#505050');
                wallGradient.addColorStop(1, '#404040');
                
                // Main wall body
                this.ctx.fillStyle = wallGradient;
                this.ctx.fillRect(this.wall.x, this.wall.y, this.wall.width, this.wall.height);
                
                // Wall top cap with metallic shine
                const topCapGradient = this.ctx.createLinearGradient(
                    this.wall.x, this.wall.y - 8,
                    this.wall.x, this.wall.y
                );
                topCapGradient.addColorStop(0, '#A0A0A0');
                topCapGradient.addColorStop(0.5, '#909090');
                topCapGradient.addColorStop(1, '#707070');
                
                this.ctx.fillStyle = topCapGradient;
                this.ctx.fillRect(this.wall.x - 3, this.wall.y - 8, this.wall.width + 6, 8);
                
                // Top cap highlight
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(this.wall.x - 3, this.wall.y - 8);
                this.ctx.lineTo(this.wall.x + this.wall.width + 3, this.wall.y - 8);
                this.ctx.stroke();
                
                // Vertical reinforcement plates
                const plateHeight = this.wall.height / 6;
                for (let i = 0; i < 6; i++) {
                    const plateY = this.wall.y + i * plateHeight;
                    
                    // Plate gradient
                    const plateGradient = this.ctx.createLinearGradient(
                        this.wall.x, plateY,
                        this.wall.x + this.wall.width, plateY + plateHeight
                    );
                    
                    if (i % 2 === 0) {
                        plateGradient.addColorStop(0, 'rgba(120, 120, 120, 0.5)');
                        plateGradient.addColorStop(0.5, 'rgba(90, 90, 90, 0.5)');
                        plateGradient.addColorStop(1, 'rgba(70, 70, 70, 0.5)');
                    } else {
                        plateGradient.addColorStop(0, 'rgba(100, 100, 100, 0.5)');
                        plateGradient.addColorStop(0.5, 'rgba(80, 80, 80, 0.5)');
                        plateGradient.addColorStop(1, 'rgba(60, 60, 60, 0.5)');
                    }
                    
                    this.ctx.fillStyle = plateGradient;
                    this.ctx.fillRect(this.wall.x, plateY, this.wall.width, plateHeight - 2);
                    
                    // Plate separation line
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.wall.x, plateY + plateHeight - 1);
                    this.ctx.lineTo(this.wall.x + this.wall.width, plateY + plateHeight - 1);
                    this.ctx.stroke();
                }
                
                // Rivets/bolts for industrial fortified look
                const rivetSpacing = this.wall.height / 5;
                for (let i = 0; i <= 5; i++) {
                    const rivetY = this.wall.y + i * rivetSpacing;
                    
                    // Left rivet
                    this.drawRivet(this.wall.x + 4, rivetY);
                    // Right rivet
                    this.drawRivet(this.wall.x + this.wall.width - 4, rivetY);
                }
                
                // Left edge highlight for 3D depth
                const leftHighlight = this.ctx.createLinearGradient(
                    this.wall.x, this.wall.y,
                    this.wall.x + 3, this.wall.y
                );
                leftHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                leftHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.fillStyle = leftHighlight;
                this.ctx.fillRect(this.wall.x, this.wall.y, 3, this.wall.height);
                
                // Right edge shadow for depth
                const rightShadow = this.ctx.createLinearGradient(
                    this.wall.x + this.wall.width - 3, this.wall.y,
                    this.wall.x + this.wall.width, this.wall.y
                );
                rightShadow.addColorStop(0, 'rgba(0, 0, 0, 0)');
                rightShadow.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
                
                this.ctx.fillStyle = rightShadow;
                this.ctx.fillRect(this.wall.x + this.wall.width - 3, this.wall.y, 3, this.wall.height);
                
                // Battle scars and wear
                this.ctx.strokeStyle = 'rgba(40, 40, 40, 0.3)';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const scarY = this.wall.y + 20 + Math.random() * (this.wall.height - 40);
                    const scarLength = 8 + Math.random() * 10;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.wall.x + 5, scarY);
                    this.ctx.lineTo(this.wall.x + 5 + scarLength, scarY + 2);
                    this.ctx.stroke();
                }
                
                // Ground shadow
                const shadowGradient = this.ctx.createLinearGradient(
                    this.wall.x, this.wall.y + this.wall.height,
                    this.wall.x, this.wall.y + this.wall.height + 15
                );
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = shadowGradient;
                this.ctx.fillRect(this.wall.x - 5, this.wall.y + this.wall.height, this.wall.width + 10, 15);

                this.repositionGameElements();
            }
            
            drawRivet(x, y) {
                // Rivet shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(x + 0.5, y + 0.5, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Rivet body with gradient
                const rivetGradient = this.ctx.createRadialGradient(
                    x - 1, y - 1, 0,
                    x, y, 2
                );
                rivetGradient.addColorStop(0, '#C0C0C0');
                rivetGradient.addColorStop(0.5, '#909090');
                rivetGradient.addColorStop(1, '#505050');
                
                this.ctx.fillStyle = rivetGradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Rivet highlight
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(x - 0.5, y - 0.5, 0.8, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawPlayer() {
                let gunAngle = 0;
                if (this.mouseX && this.mouseY) {
                    const dx = this.mouseX - this.player.x;
                    const dy = this.mouseY - this.player.y;
                    gunAngle = Math.atan2(dy, dx);
                }
                
                // 3D Body with gradient
                const bodyGradient = this.ctx.createLinearGradient(
                    this.player.x - 13, this.player.y - 5,
                    this.player.x + 13, this.player.y + 27
                );
                bodyGradient.addColorStop(0, '#6495ED');
                bodyGradient.addColorStop(0.3, '#4169E1');
                bodyGradient.addColorStop(0.7, '#2E4BC7');
                bodyGradient.addColorStop(1, '#1E3A8A');
                
                // Draw body with rounded corners for 3D effect
                this.ctx.fillStyle = bodyGradient;
                this.ctx.beginPath();
                this.ctx.roundRect(this.player.x - 13, this.player.y - 5, 26, 32, 4);
                this.ctx.fill();
                
                // Body highlight for 3D effect
                const bodyHighlight = this.ctx.createLinearGradient(
                    this.player.x - 10, this.player.y - 3,
                    this.player.x - 5, this.player.y + 5
                );
                bodyHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                bodyHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                this.ctx.fillStyle = bodyHighlight;
                this.ctx.fillRect(this.player.x - 10, this.player.y - 3, 5, 10);
                
                // Add collar
                this.ctx.fillStyle = '#1E3A8A';
                this.ctx.fillRect(this.player.x - 13, this.player.y - 5, 26, 4);
                
                // Buttons on shirt
                this.ctx.fillStyle = 'white';
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y + 3 + i * 8, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 3D Head with spherical gradient
                const headY = this.player.y - 10;
                const headGradient = this.ctx.createRadialGradient(
                    this.player.x - this.player.size * 0.3, 
                    headY - this.player.size * 0.3, 
                    0,
                    this.player.x, 
                    headY, 
                    this.player.size
                );
                headGradient.addColorStop(0, '#FFD4E5');
                headGradient.addColorStop(0.3, '#FFB6C1');
                headGradient.addColorStop(0.7, '#FF91A4');
                headGradient.addColorStop(1, '#E57388');
                
                this.ctx.fillStyle = headGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, headY, this.player.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Head edge shadow for depth
                const shadowGradient = this.ctx.createRadialGradient(
                    this.player.x, headY, this.player.size * 0.8,
                    this.player.x, headY, this.player.size
                );
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
                this.ctx.fillStyle = shadowGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, headY, this.player.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Primary head highlight
                const highlightGradient = this.ctx.createRadialGradient(
                    this.player.x - this.player.size * 0.4,
                    headY - this.player.size * 0.4,
                    0,
                    this.player.x - this.player.size * 0.2,
                    headY - this.player.size * 0.2,
                    this.player.size * 0.4
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, headY, this.player.size * 0.9, 0, Math.PI * 2);
                this.ctx.clip();
                
                this.ctx.fillStyle = highlightGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - this.player.size * 0.3, headY - this.player.size * 0.3, this.player.size * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // 3D Eyes with depth
                // Eye whites with subtle gradient
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 6, headY - 5, 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 6, headY - 5, 4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Eye shadows
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 6, headY - 4, 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 6, headY - 4, 4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupils with gradient
                const pupilGradient = this.ctx.createRadialGradient(
                    this.player.x - 6, headY - 5, 0,
                    this.player.x - 6, headY - 5, 2
                );
                pupilGradient.addColorStop(0, '#000000');
                pupilGradient.addColorStop(1, '#333333');
                
                this.ctx.fillStyle = pupilGradient;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 6, headY - 5, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                const pupilGradient2 = this.ctx.createRadialGradient(
                    this.player.x + 6, headY - 5, 0,
                    this.player.x + 6, headY - 5, 2
                );
                pupilGradient2.addColorStop(0, '#000000');
                pupilGradient2.addColorStop(1, '#333333');
                
                this.ctx.fillStyle = pupilGradient2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 6, headY - 5, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Eye highlights
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x - 7, headY - 6, 1, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 5, headY - 6, 1, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 3D Smile
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                this.ctx.lineWidth = 2.5;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, headY + 5, 5, 0, Math.PI);
                this.ctx.stroke();
                
                // 3D Gun with metallic gradient
                const gunGradient = this.ctx.createLinearGradient(
                    this.player.x + 18, this.player.y + 6,
                    this.player.x + 18, this.player.y + 10
                );
                gunGradient.addColorStop(0, '#5F6F6F');
                gunGradient.addColorStop(0.3, '#3F4F4F');
                gunGradient.addColorStop(0.7, '#2F3F3F');
                gunGradient.addColorStop(1, '#1F2F2F');
                
                // Gun barrel with gradient
                this.ctx.strokeStyle = gunGradient;
                this.ctx.lineWidth = 6;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + 18, this.player.y + 8);
                
                const gunLength = 30;
                const gunEndX = this.player.x + 18 + Math.cos(gunAngle) * gunLength;
                const gunEndY = this.player.y + 8 + Math.sin(gunAngle) * gunLength;
                
                this.ctx.lineTo(gunEndX, gunEndY);
                this.ctx.stroke();
                
                // Gun highlight
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + 18, this.player.y + 6);
                this.ctx.lineTo(gunEndX - Math.cos(gunAngle) * 3, gunEndY - Math.sin(gunAngle) * 0.5 - 2);
                this.ctx.stroke();
                
                // Gun muzzle
                this.ctx.fillStyle = '#1F2F2F';
                this.ctx.beginPath();
                this.ctx.arc(gunEndX, gunEndY, 4, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.fillStyle = '#000000';
                this.ctx.beginPath();
                this.ctx.arc(gunEndX, gunEndY, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 3D Arm holding gun with gradient
                const armGradient = this.ctx.createLinearGradient(
                    this.player.x + 13, this.player.y + 10,
                    this.player.x + 24, this.player.y + 20
                );
                armGradient.addColorStop(0, '#FFD4E5');
                armGradient.addColorStop(0.5, '#FFB6C1');
                armGradient.addColorStop(1, '#E57388');
                
                this.ctx.strokeStyle = armGradient;
                this.ctx.lineWidth = 5;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x + 13, this.player.y + 10);
                this.ctx.lineTo(this.player.x + 20, this.player.y + 15);
                this.ctx.stroke();
                
                // Hand at gun grip
                this.ctx.fillStyle = '#FFB6C1';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 20, this.player.y + 15, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Hand highlight
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + 19, this.player.y + 14, 1, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawTurret(turret, turretNumber = 1) {
                // 3D Range indicator with gradient
                const rangeGradient = this.ctx.createRadialGradient(
                    turret.x, turret.y, turret.range * 0.7,
                    turret.x, turret.y, turret.range
                );
                rangeGradient.addColorStop(0, 'rgba(128, 0, 128, 0.02)');
                rangeGradient.addColorStop(0.7, 'rgba(128, 0, 128, 0.05)');
                rangeGradient.addColorStop(1, 'rgba(128, 0, 128, 0.1)');
                
                this.ctx.fillStyle = rangeGradient;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y, turret.range, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Range border with glow effect
                this.ctx.strokeStyle = 'rgba(128, 0, 128, 0.2)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y, turret.range, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Pulse effect on range
                const pulseAlpha = 0.1 + 0.05 * Math.sin(Date.now() * 0.002);
                this.ctx.strokeStyle = `rgba(147, 0, 211, ${pulseAlpha})`;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y, turret.range - 2, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // 3D Turret base with metallic gradient
                const baseGradient = this.ctx.createLinearGradient(
                    turret.x - 15, turret.y - 10,
                    turret.x + 15, turret.y + 10
                );
                baseGradient.addColorStop(0, '#8A8A8A');
                baseGradient.addColorStop(0.3, '#696969');
                baseGradient.addColorStop(0.7, '#505050');
                baseGradient.addColorStop(1, '#303030');
                
                // Base with rounded corners
                this.ctx.fillStyle = baseGradient;
                this.ctx.beginPath();
                this.ctx.roundRect(turret.x - 15, turret.y - 10, 30, 20, 3);
                this.ctx.fill();
                
                // Base edge highlight for 3D effect
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.roundRect(turret.x - 14, turret.y - 9, 28, 18, 2);
                this.ctx.stroke();
                
                // Metal plate details
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(turret.x - 12, turret.y - 7, 24, 1);
                this.ctx.fillRect(turret.x - 12, turret.y + 6, 24, 1);
                
                // Bolts/rivets for industrial look
                const boltPositions = [
                    { x: turret.x - 10, y: turret.y - 5 },
                    { x: turret.x + 10, y: turret.y - 5 },
                    { x: turret.x - 10, y: turret.y + 5 },
                    { x: turret.x + 10, y: turret.y + 5 }
                ];
                
                for (const bolt of boltPositions) {
                    // Bolt shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    this.ctx.beginPath();
                    this.ctx.arc(bolt.x, bolt.y, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Bolt with gradient
                    const boltGradient = this.ctx.createRadialGradient(
                        bolt.x - 0.5, bolt.y - 0.5, 0,
                        bolt.x, bolt.y, 1.2
                    );
                    boltGradient.addColorStop(0, '#C0C0C0');
                    boltGradient.addColorStop(1, '#606060');
                    
                    this.ctx.fillStyle = boltGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bolt.x, bolt.y, 1.2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Find nearest enemy for barrel rotation
                let barrelAngle = -Math.PI / 2; // Default upward
                const nearestBalloon = this.findNearestBalloon(turret.x, turret.y);
                if (nearestBalloon) {
                    const dx = nearestBalloon.x - turret.x;
                    const dy = nearestBalloon.y - turret.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < turret.range) {
                        barrelAngle = Math.atan2(dy, dx);
                    }
                }
                
                // 3D Rotating barrel mount
                const mountGradient = this.ctx.createRadialGradient(
                    turret.x - 2, turret.y - 2, 0,
                    turret.x, turret.y, 6
                );
                mountGradient.addColorStop(0, '#707070');
                mountGradient.addColorStop(0.7, '#505050');
                mountGradient.addColorStop(1, '#303030');
                
                this.ctx.fillStyle = mountGradient;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Mount highlight
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 0.5;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y, 4, -Math.PI/3, -Math.PI/6);
                this.ctx.stroke();
                
                // 3D Gun barrel with gradient
                const barrelEndX = turret.x + Math.cos(barrelAngle) * 22;
                const barrelEndY = turret.y + Math.sin(barrelAngle) * 22;
                
                const barrelGradient = this.ctx.createLinearGradient(
                    turret.x, turret.y,
                    barrelEndX, barrelEndY
                );
                barrelGradient.addColorStop(0, '#4F5F5F');
                barrelGradient.addColorStop(0.3, '#3F4F4F');
                barrelGradient.addColorStop(0.7, '#2F3F3F');
                barrelGradient.addColorStop(1, '#1F2F2F');
                
                this.ctx.strokeStyle = barrelGradient;
                this.ctx.lineWidth = 7;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(turret.x, turret.y);
                this.ctx.lineTo(barrelEndX, barrelEndY);
                this.ctx.stroke();
                
                // Barrel highlight for metallic shine
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    turret.x + Math.cos(barrelAngle - 0.15) * 3, 
                    turret.y + Math.sin(barrelAngle - 0.15) * 3
                );
                this.ctx.lineTo(
                    barrelEndX + Math.cos(barrelAngle - 0.15) * 1, 
                    barrelEndY + Math.sin(barrelAngle - 0.15) * 1
                );
                this.ctx.stroke();
                
                // Barrel muzzle with depth
                this.ctx.fillStyle = '#1F2F2F';
                this.ctx.beginPath();
                this.ctx.arc(barrelEndX, barrelEndY, 4.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#000000';
                this.ctx.beginPath();
                this.ctx.arc(barrelEndX, barrelEndY, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Level indicator with 3D badge
                const badgeGradient = this.ctx.createRadialGradient(
                    turret.x - 2, turret.y + 18, 0,
                    turret.x, turret.y + 20, 8
                );
                badgeGradient.addColorStop(0, '#FFD700');
                badgeGradient.addColorStop(0.7, '#FFA500');
                badgeGradient.addColorStop(1, '#FF8C00');
                
                this.ctx.fillStyle = badgeGradient;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y + 20, 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Badge border
                this.ctx.strokeStyle = '#B8860B';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(turret.x, turret.y + 20, 8, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Turret number text with shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(translate('turretLabel', {number: turretNumber}), turret.x + 0.5, turret.y + 20.5);
                
                this.ctx.fillStyle = 'white';
                this.ctx.fillText(translate('turretLabel', {number: turretNumber}), turret.x, turret.y + 20);
            }
            
            drawTurretPlacementLine() {
                const lineX = this.wall.x + this.wall.width + 20;
                const originalHeight = this.height - 20 - (this.wall.y + 10);
                const newHeight = originalHeight * 4.375;
                const lineStartY = this.wall.y + 10 - (newHeight - originalHeight);
                const lineEndY = this.height - 20;
                
                this.ctx.strokeStyle = '#FF0000';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, lineStartY);
                this.ctx.lineTo(lineX, lineEndY);
                this.ctx.stroke();
                
                const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
                this.ctx.strokeStyle = `rgba(255, 0, 0, ${pulseAlpha})`;
                this.ctx.lineWidth = 8;
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, lineStartY);
                this.ctx.lineTo(lineX, lineEndY);
                this.ctx.stroke();
                
                // Instruction panel background
                const text = t.clickToPlaceTurret;
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                const textWidth = this.ctx.measureText(text).width;
                
                // Panel background with gradient
                const panelGradient = this.ctx.createLinearGradient(
                    this.width / 2 - textWidth / 2 - 20, 30,
                    this.width / 2 + textWidth / 2 + 20, 60
                );
                panelGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                panelGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.9)');
                panelGradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                
                this.ctx.fillStyle = panelGradient;
                this.ctx.fillRect(
                    this.width / 2 - textWidth / 2 - 20, 
                    30, 
                    textWidth + 40, 
                    35
                );
                
                // Panel border
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(
                    this.width / 2 - textWidth / 2 - 20, 
                    30, 
                    textWidth + 40, 
                    35
                );
                
                // Text shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillText(text, this.width / 2 + 2, 52);
                
                // Main text
                this.ctx.fillStyle = 'white';
                this.ctx.fillText(text, this.width / 2, 50);
            }
            
            drawTurretPlacementPreview() {
                if (!this.mouseX || !this.mouseY) return;
                
                const lineX = this.wall.x + this.wall.width + 20;
                const originalHeight = this.height - 20 - (this.wall.y + 10);
                const newHeight = originalHeight * 4.375;
                const lineStartY = this.wall.y + 10 - (newHeight - originalHeight);
                const lineEndY = this.height - 20;
                
                if (Math.abs(this.mouseX - lineX) <= 30 && this.mouseY >= lineStartY && this.mouseY <= lineEndY) {
                    // Preview range with gradient (semi-transparent)
                    const rangeGradient = this.ctx.createRadialGradient(
                        lineX, this.mouseY, 400 * 0.7,
                        lineX, this.mouseY, 400
                    );
                    rangeGradient.addColorStop(0, 'rgba(255, 215, 0, 0.05)');
                    rangeGradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.15)');
                    rangeGradient.addColorStop(1, 'rgba(255, 215, 0, 0.25)');
                    
                    this.ctx.fillStyle = rangeGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY, 400, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY, 400, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Pulsing preview range
                    const pulseAlpha = 0.2 + 0.1 * Math.sin(Date.now() * 0.003);
                    this.ctx.strokeStyle = `rgba(255, 215, 0, ${pulseAlpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY, 398, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // 3D Preview turret base with metallic gradient (semi-transparent)
                    const baseGradient = this.ctx.createLinearGradient(
                        lineX - 15, this.mouseY - 10,
                        lineX + 15, this.mouseY + 10
                    );
                    baseGradient.addColorStop(0, 'rgba(138, 138, 138, 0.8)');
                    baseGradient.addColorStop(0.3, 'rgba(105, 105, 105, 0.8)');
                    baseGradient.addColorStop(0.7, 'rgba(80, 80, 80, 0.8)');
                    baseGradient.addColorStop(1, 'rgba(48, 48, 48, 0.8)');
                    
                    // Base with rounded corners
                    this.ctx.fillStyle = baseGradient;
                    this.ctx.beginPath();
                    this.ctx.roundRect(lineX - 15, this.mouseY - 10, 30, 20, 3);
                    this.ctx.fill();
                    
                    // Base edge highlight
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.roundRect(lineX - 14, this.mouseY - 9, 28, 18, 2);
                    this.ctx.stroke();
                    
                    // Metal plate details
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.fillRect(lineX - 12, this.mouseY - 7, 24, 1);
                    this.ctx.fillRect(lineX - 12, this.mouseY + 6, 24, 1);
                    
                    // Preview bolts
                    const boltPositions = [
                        { x: lineX - 10, y: this.mouseY - 5 },
                        { x: lineX + 10, y: this.mouseY - 5 },
                        { x: lineX - 10, y: this.mouseY + 5 },
                        { x: lineX + 10, y: this.mouseY + 5 }
                    ];
                    
                    for (const bolt of boltPositions) {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.beginPath();
                        this.ctx.arc(bolt.x, bolt.y, 1.5, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        const boltGradient = this.ctx.createRadialGradient(
                            bolt.x - 0.5, bolt.y - 0.5, 0,
                            bolt.x, bolt.y, 1.2
                        );
                        boltGradient.addColorStop(0, 'rgba(192, 192, 192, 0.8)');
                        boltGradient.addColorStop(1, 'rgba(96, 96, 96, 0.8)');
                        
                        this.ctx.fillStyle = boltGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(bolt.x, bolt.y, 1.2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // 3D Rotating barrel mount preview
                    const mountGradient = this.ctx.createRadialGradient(
                        lineX - 2, this.mouseY - 2, 0,
                        lineX, this.mouseY, 6
                    );
                    mountGradient.addColorStop(0, 'rgba(112, 112, 112, 0.8)');
                    mountGradient.addColorStop(0.7, 'rgba(80, 80, 80, 0.8)');
                    mountGradient.addColorStop(1, 'rgba(48, 48, 48, 0.8)');
                    
                    this.ctx.fillStyle = mountGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Mount highlight
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY, 4, -Math.PI/3, -Math.PI/6);
                    this.ctx.stroke();
                    
                    // Preview barrel (pointing upward)
                    const barrelAngle = -Math.PI / 2;
                    const barrelEndX = lineX + Math.cos(barrelAngle) * 22;
                    const barrelEndY = this.mouseY + Math.sin(barrelAngle) * 22;
                    
                    const barrelGradient = this.ctx.createLinearGradient(
                        lineX, this.mouseY,
                        barrelEndX, barrelEndY
                    );
                    barrelGradient.addColorStop(0, 'rgba(79, 95, 95, 0.8)');
                    barrelGradient.addColorStop(0.3, 'rgba(63, 79, 79, 0.8)');
                    barrelGradient.addColorStop(0.7, 'rgba(47, 63, 63, 0.8)');
                    barrelGradient.addColorStop(1, 'rgba(31, 47, 47, 0.8)');
                    
                    this.ctx.strokeStyle = barrelGradient;
                    this.ctx.lineWidth = 7;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(lineX, this.mouseY);
                    this.ctx.lineTo(barrelEndX, barrelEndY);
                    this.ctx.stroke();
                    
                    // Barrel highlight
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        lineX + Math.cos(barrelAngle - 0.15) * 3,
                        this.mouseY + Math.sin(barrelAngle - 0.15) * 3
                    );
                    this.ctx.lineTo(
                        barrelEndX + Math.cos(barrelAngle - 0.15) * 1,
                        barrelEndY + Math.sin(barrelAngle - 0.15) * 1
                    );
                    this.ctx.stroke();
                    
                    // Barrel muzzle
                    this.ctx.fillStyle = 'rgba(31, 47, 47, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(barrelEndX, barrelEndY, 4.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(barrelEndX, barrelEndY, 2.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Level badge preview
                    const badgeGradient = this.ctx.createRadialGradient(
                        lineX - 2, this.mouseY + 18, 0,
                        lineX, this.mouseY + 20, 8
                    );
                    badgeGradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    badgeGradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.8)');
                    badgeGradient.addColorStop(1, 'rgba(255, 140, 0, 0.8)');
                    
                    this.ctx.fillStyle = badgeGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY + 20, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = 'rgba(184, 134, 11, 0.8)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(lineX, this.mouseY + 20, 8, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Turret number text with shadow (showing next turret number)
                    const nextTurretNumber = this.turrets.length + 1;
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(translate('turretLabel', {number: nextTurretNumber}), lineX + 0.5, this.mouseY + 20.5);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillText(translate('turretLabel', {number: nextTurretNumber}), lineX, this.mouseY + 20);
                }
            }
            
            drawBalloon(balloon) {
                // Create 3D effect with radial gradient
                const gradient = this.ctx.createRadialGradient(
                    balloon.x - balloon.size * 0.3, 
                    balloon.y - balloon.size * 0.3, 
                    0,
                    balloon.x, 
                    balloon.y, 
                    balloon.size
                );
                
                // Parse balloon color to create gradient stops
                let baseColor = balloon.color;
                let darkColor = this.darkenColor(balloon.color, 0.4);
                let lightColor = this.lightenColor(balloon.color, 0.3);
                
                gradient.addColorStop(0, lightColor);
                gradient.addColorStop(0.4, baseColor);
                gradient.addColorStop(1, darkColor);
                
                // Draw main balloon body with gradient
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(balloon.x, balloon.y, balloon.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add subtle edge shadow for depth
                const shadowGradient = this.ctx.createRadialGradient(
                    balloon.x, balloon.y, balloon.size * 0.8,
                    balloon.x, balloon.y, balloon.size
                );
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                this.ctx.fillStyle = shadowGradient;
                this.ctx.beginPath();
                this.ctx.arc(balloon.x, balloon.y, balloon.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Primary highlight (specular reflection)
                const highlightGradient = this.ctx.createRadialGradient(
                    balloon.x - balloon.size * 0.3,
                    balloon.y - balloon.size * 0.3,
                    0,
                    balloon.x - balloon.size * 0.2,
                    balloon.y - balloon.size * 0.2,
                    balloon.size * 0.5
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                highlightGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(balloon.x, balloon.y, balloon.size * 0.9, 0, Math.PI * 2);
                this.ctx.clip();
                
                this.ctx.fillStyle = highlightGradient;
                this.ctx.beginPath();
                this.ctx.arc(balloon.x - balloon.size * 0.2, balloon.y - balloon.size * 0.2, balloon.size * 0.6, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // Secondary smaller highlight for extra shininess
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.beginPath();
                this.ctx.ellipse(balloon.x - balloon.size * 0.35, balloon.y - balloon.size * 0.4, 
                    balloon.size * 0.15, balloon.size * 0.1, -Math.PI / 6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw 3D eyes with depth
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(balloon.x - 8, balloon.y - 5, 5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(balloon.x + 8, balloon.y - 5, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add eye shadows
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.beginPath();
                this.ctx.arc(balloon.x - 8, balloon.y - 4, 5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(balloon.x + 8, balloon.y - 4, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupils
                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(balloon.x - 8, balloon.y - 5, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(balloon.x + 8, balloon.y - 5, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Eye highlights
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(balloon.x - 9, balloon.y - 6, 1, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(balloon.x + 7, balloon.y - 6, 1, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Mouth with 3D effect
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.lineWidth = 2.5;
                this.ctx.beginPath();
                this.ctx.arc(balloon.x, balloon.y + 8, 6, 0, Math.PI);
                this.ctx.stroke();
                
                // String with shadow
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(balloon.x + 1, balloon.y + balloon.size);
                this.ctx.lineTo(balloon.x + 1, balloon.y + balloon.size + 20);
                this.ctx.stroke();
                
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(balloon.x, balloon.y + balloon.size);
                this.ctx.lineTo(balloon.x, balloon.y + balloon.size + 20);
                this.ctx.stroke();
                
                // Special rendering for super armored balloon - add helmet
                if (balloon.type === 'superarmored') {
                    // Metal helmet base
                    this.ctx.fillStyle = '#34495E';
                    this.ctx.beginPath();
                    this.ctx.ellipse(balloon.x, balloon.y - balloon.size * 0.6, 
                        balloon.size * 0.8, balloon.size * 0.5, 0, Math.PI, 0);
                    this.ctx.fill();
                    
                    // Helmet shine
                    const helmetGradient = this.ctx.createLinearGradient(
                        balloon.x - balloon.size * 0.6, balloon.y - balloon.size * 0.8,
                        balloon.x + balloon.size * 0.6, balloon.y - balloon.size * 0.4
                    );
                    helmetGradient.addColorStop(0, '#5D6D7E');
                    helmetGradient.addColorStop(0.5, '#85929E');
                    helmetGradient.addColorStop(1, '#34495E');
                    
                    this.ctx.fillStyle = helmetGradient;
                    this.ctx.beginPath();
                    this.ctx.ellipse(balloon.x, balloon.y - balloon.size * 0.6, 
                        balloon.size * 0.75, balloon.size * 0.45, 0, Math.PI, 0);
                    this.ctx.fill();
                    
                    // Helmet spike on top
                    this.ctx.fillStyle = '#2C3E50';
                    this.ctx.beginPath();
                    this.ctx.moveTo(balloon.x - 5, balloon.y - balloon.size * 0.9);
                    this.ctx.lineTo(balloon.x, balloon.y - balloon.size * 1.1);
                    this.ctx.lineTo(balloon.x + 5, balloon.y - balloon.size * 0.9);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Helmet strap
                    this.ctx.strokeStyle = '#1C2833';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(balloon.x - balloon.size * 0.6, balloon.y - balloon.size * 0.4);
                    this.ctx.quadraticCurveTo(balloon.x, balloon.y, 
                        balloon.x + balloon.size * 0.6, balloon.y - balloon.size * 0.4);
                    this.ctx.stroke();
                }
                
                // Special rendering for stealth balloon - flickering effect
                if (balloon.type === 'stealth') {
                    // Create flickering opacity effect
                    const flicker = Math.sin(Date.now() * 0.005 + balloon.x) * 0.3 + 0.3;
                    this.ctx.globalAlpha = flicker;
                    
                    // Draw distortion waves around balloon
                    this.ctx.strokeStyle = 'rgba(149, 165, 166, 0.3)';
                    this.ctx.lineWidth = 1;
                    for (let i = 1; i <= 3; i++) {
                        this.ctx.beginPath();
                        this.ctx.arc(balloon.x, balloon.y, balloon.size + i * 8, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    this.ctx.globalAlpha = 1;
                }
                
                if (balloon.hp < balloon.maxHP) {
                    const barWidth = balloon.size * 1.5;
                    const hpPercentage = balloon.hp / balloon.maxHP;
                    
                    this.ctx.fillStyle = 'red';
                    this.ctx.fillRect(balloon.x - barWidth/2, balloon.y - balloon.size - 15, barWidth, 4);
                    this.ctx.fillStyle = 'green';
                    this.ctx.fillRect(balloon.x - barWidth/2, balloon.y - balloon.size - 15, barWidth * hpPercentage, 4);
                }
                
                // Special balloon type effects with 3D enhancements
                if (balloon.type === 'armored') {
                    // Metallic armor ring with gradient
                    const armorGradient = this.ctx.createLinearGradient(
                        balloon.x - balloon.size, balloon.y - balloon.size,
                        balloon.x + balloon.size, balloon.y + balloon.size
                    );
                    armorGradient.addColorStop(0, '#E0E0E0');
                    armorGradient.addColorStop(0.5, '#C0C0C0');
                    armorGradient.addColorStop(1, '#808080');
                    
                    this.ctx.strokeStyle = armorGradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y, balloon.size + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Metallic shine on armor
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y, balloon.size + 4, -Math.PI/3, -Math.PI/6);
                    this.ctx.stroke();
                } else if (balloon.type === 'heavy') {
                    // Metallic armor with weight indicator
                    const armorGradient = this.ctx.createLinearGradient(
                        balloon.x - balloon.size, balloon.y - balloon.size,
                        balloon.x + balloon.size, balloon.y + balloon.size
                    );
                    armorGradient.addColorStop(0, '#D0D0D0');
                    armorGradient.addColorStop(0.5, '#A0A0A0');
                    armorGradient.addColorStop(1, '#707070');
                    
                    this.ctx.strokeStyle = armorGradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y, balloon.size + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // 3D weight emblem
                    const weightGradient = this.ctx.createRadialGradient(
                        balloon.x - 3, balloon.y - balloon.size * 0.5 - 3,
                        0,
                        balloon.x, balloon.y - balloon.size * 0.5,
                        balloon.size * 0.4
                    );
                    weightGradient.addColorStop(0, '#C0C0C0');
                    weightGradient.addColorStop(0.7, '#808080');
                    weightGradient.addColorStop(1, '#505050');
                    
                    this.ctx.fillStyle = weightGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y - balloon.size * 0.5, balloon.size * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Weight text with shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.font = `bold ${balloon.size * 0.3}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('W', balloon.x + 1, balloon.y - balloon.size * 0.42);
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillText('W', balloon.x, balloon.y - balloon.size * 0.43);
                } else if (balloon.type === 'giant') {
                    // Double metallic rings with 3D effect
                    const armorGradient1 = this.ctx.createLinearGradient(
                        balloon.x - balloon.size, balloon.y - balloon.size,
                        balloon.x + balloon.size, balloon.y + balloon.size
                    );
                    armorGradient1.addColorStop(0, '#F0F0F0');
                    armorGradient1.addColorStop(0.5, '#C0C0C0');
                    armorGradient1.addColorStop(1, '#808080');
                    
                    this.ctx.strokeStyle = armorGradient1;
                    this.ctx.lineWidth = 5;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y, balloon.size + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    const armorGradient2 = this.ctx.createLinearGradient(
                        balloon.x - balloon.size, balloon.y - balloon.size,
                        balloon.x + balloon.size, balloon.y + balloon.size
                    );
                    armorGradient2.addColorStop(0, '#FFE4B5');
                    armorGradient2.addColorStop(0.5, '#FFD700');
                    armorGradient2.addColorStop(1, '#B8860B');
                    
                    this.ctx.strokeStyle = armorGradient2;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y, balloon.size + 7, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // 3D crown with gradient
                    const crownGradient = this.ctx.createLinearGradient(
                        balloon.x - 8, balloon.y - balloon.size * 0.7 - 4,
                        balloon.x + 8, balloon.y - balloon.size * 0.7 + 8
                    );
                    crownGradient.addColorStop(0, '#FFEF94');
                    crownGradient.addColorStop(0.5, '#FFD700');
                    crownGradient.addColorStop(1, '#B8860B');
                    
                    this.ctx.fillStyle = crownGradient;
                    this.ctx.fillRect(balloon.x - 8, balloon.y - balloon.size * 0.7, 16, 8);
                    for (let i = 0; i < 3; i++) {
                        this.ctx.fillRect(balloon.x - 6 + i * 6, balloon.y - balloon.size * 0.7 - 4, 4, 6);
                    }
                    
                    // Crown jewels
                    this.ctx.fillStyle = '#FF1493';
                    this.ctx.beginPath();
                    this.ctx.arc(balloon.x, balloon.y - balloon.size * 0.66, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (balloon.type === 'speed') {
                    // Speed lines with gradient effect
                    for (let i = 0; i < 3; i++) {
                        const speedGradient = this.ctx.createLinearGradient(
                            balloon.x + balloon.size + 5 + i * 8, balloon.y - 5 + i * 3,
                            balloon.x + balloon.size + 20 + i * 8, balloon.y - 5 + i * 3
                        );
                        
                        if (balloon.hasSpeedBoost) {
                            speedGradient.addColorStop(0, 'rgba(255, 100, 100, 0.9)');
                            speedGradient.addColorStop(1, 'rgba(255, 200, 200, 0.2)');
                        } else {
                            speedGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            speedGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                        }
                        
                        this.ctx.strokeStyle = speedGradient;
                        this.ctx.lineWidth = balloon.hasSpeedBoost ? 3 - i * 0.5 : 2 - i * 0.3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(balloon.x + balloon.size + 5 + i * 8, balloon.y - 5 + i * 3);
                        this.ctx.lineTo(balloon.x + balloon.size + 20 + i * 8, balloon.y - 5 + i * 3);
                        this.ctx.stroke();
                    }
                    
                    if (balloon.hasSpeedBoost) {
                        // Energy aura with gradient
                        const auraGradient = this.ctx.createRadialGradient(
                            balloon.x, balloon.y, balloon.size,
                            balloon.x, balloon.y, balloon.size + 8
                        );
                        auraGradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                        auraGradient.addColorStop(0.7, 'rgba(255, 50, 50, 0.3)');
                        auraGradient.addColorStop(1, 'rgba(255, 100, 100, 0.6)');
                        
                        this.ctx.fillStyle = auraGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(balloon.x, balloon.y, balloon.size + 8, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            updateUI() {
                document.getElementById('coins').textContent = this.coins;
                document.getElementById('houseHP').textContent = Math.max(0, this.houseHP);
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('gunLevel').textContent = this.player.gunLevel;
                document.getElementById('turretStrength').textContent = this.turretStrength;
                
                // Update balloon strength indicator
                const waveMultiplierLevel = Math.floor(this.wave / 10);
                let strengthIncrease;
                switch (this.difficulty) {
                    case 'easy': strengthIncrease = 1.5; break;    // 50% increase per 10 waves
                    case 'normal': strengthIncrease = 1.75; break; // 75% increase per 10 waves
                    case 'hard': strengthIncrease = 2.0; break;    // 100% increase per 10 waves (double)
                    default: strengthIncrease = 1.75;
                }
                const balloonStrength = Math.pow(strengthIncrease, waveMultiplierLevel);
                document.getElementById('balloonStrength').textContent = balloonStrength.toFixed(1);
                
                // Turret info display removed
                
                const remainingEnemies = this.waveActive ? 
                    (this.enemiesInWave - this.enemiesSpawned) + this.balloons.length : 
                    this.balloons.length;
                document.getElementById('enemiesLeft').textContent = Math.max(0, remainingEnemies);
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalCoins').textContent = this.coins;
                document.getElementById('finalWave').textContent = this.wave - 1;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
    </script>
</body>
</html>